<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CosyVoice è¯­éŸ³åˆæˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'PingFang SC', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            max-width: 800px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 32px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 600;
        }

        input[type="text"],
        textarea,
        select {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
            font-family: inherit;
            background: white;
        }

        textarea {
            min-height: 180px;
            resize: vertical;
            line-height: 1.6;
        }

        input[type="text"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
        }

        /* è‡ªåŠ¨æ’­æ”¾å¼€å…³æ ·å¼ */
        .switch-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 12px 16px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .switch-group label {
            margin: 0;
            font-weight: 600;
            color: #555;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 26px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        input:checked + .slider:before {
            transform: translateX(24px);
        }

        select {
            cursor: pointer;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        button {
            flex: 1;
            padding: 14px 28px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        #generateBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        #generateBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        #generateBtn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .audio-section {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            display: none;
        }

        .audio-section.show {
            display: block;
        }

        .audio-info {
            text-align: center;
            margin-bottom: 15px;
            color: #666;
            font-size: 14px;
        }

        .audio-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .audio-player-wrapper {
            width: 100%;
        }

        audio {
            width: 100%;
            height: 40px;
        }

        /* éšè—åŸç”ŸéŸ³é¢‘æ§ä»¶çš„ä¸‹è½½æŒ‰é’® */
        audio::-webkit-media-controls-enclosure {
            max-width: 100%;
        }

        .download-actions {
            display: flex;
            gap: 10px;
        }

        #downloadBtn {
            flex: 1;
            background: #28a745;
            color: white;
            padding: 12px 20px;
            min-width: 120px;
        }

        #downloadBtn:hover:not(:disabled) {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        #downloadBtn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #clearBtn {
            background: #6c757d;
            color: white;
            padding: 12px 20px;
            min-width: 100px;
        }

        #clearBtn:hover {
            background: #5a6268;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
        }

        .status {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
        }

        .status.show {
            display: block;
        }

        .status.loading {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        .loading-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #1976d2;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ™ï¸ CosyVoice è¯­éŸ³åˆæˆ</h1>
        
        <div class="input-group">
            <label for="textInput">è¾“å…¥æ–‡æœ¬ï¼š</label>
            <textarea id="textInput" placeholder="è¯·è¾“å…¥è¦åˆæˆçš„æ–‡æœ¬å†…å®¹..."></textarea>
        </div>

        <div class="input-group">
            <label for="speakerSelect">é€‰æ‹©è¯´è¯äººï¼š</label>
            <select id="speakerSelect">
                <option value="">æ­£åœ¨åŠ è½½...</option>
            </select>
        </div>

        <div class="switch-group">
            <label for="autoPlaySwitch">
                ğŸ”Š è‡ªåŠ¨æ’­æ”¾
                <span style="font-size: 12px; color: #999; font-weight: normal;">(å…³é—­åä»…åœ¨åå°æ¥æ”¶éŸ³é¢‘æ•°æ®)</span>
            </label>
            <label class="switch">
                <input type="checkbox" id="autoPlaySwitch" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="button-group">
            <button id="generateBtn">ğŸµ ç”Ÿæˆè¯­éŸ³</button>
        </div>

        <div class="status" id="status"></div>

        <div class="audio-section" id="audioSection">
            <div class="audio-info" id="audioInfo">
                ğŸµ éŸ³é¢‘ç”Ÿæˆä¸­...
            </div>
            <div class="audio-controls">
                <div class="audio-player-wrapper">
                    <audio id="audioPlayer" controls controlsList="nodownload"></audio>
                </div>
                <div class="download-actions">
                    <button id="downloadBtn">ğŸ“¥ ä¸‹è½½éŸ³é¢‘</button>
                    <button id="clearBtn">ğŸ—‘ï¸ æ¸…é™¤</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const textInput = document.getElementById('textInput');
        const speakerSelect = document.getElementById('speakerSelect');
        const generateBtn = document.getElementById('generateBtn');
        const audioSection = document.getElementById('audioSection');
        const audioPlayer = document.getElementById('audioPlayer');
        const downloadBtn = document.getElementById('downloadBtn');
        const clearBtn = document.getElementById('clearBtn');
        const autoPlaySwitch = document.getElementById('autoPlaySwitch');
        const audioInfo = document.getElementById('audioInfo');
        const status = document.getElementById('status');

        let audioChunks = [];
        let audioContext = null;
        let nextPlayTime = 0;
        let isStreamingComplete = false;
        let isFirstChunk = true;
        let pendingBytes = new Uint8Array(0); // ç”¨äºå­˜å‚¨ä¸å®Œæ•´çš„å­—èŠ‚
        let availableSpeakers = [];
        
        // è°ƒè¯•ä¿¡æ¯ï¼šé¦–åŒ…å»¶è¿Ÿç›¸å…³
        let requestStartTime = 0;
        let firstChunkTime = 0;
        let firstChunkSize = 0;

        /**
         * å¸¦æ—¶é—´æˆ³çš„æ—¥å¿—è¾“å‡º
         */
        function log(message, type = 'info') {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('zh-CN', { hour12: false }) + '.' + now.getMilliseconds().toString().padStart(3, '0');
            console.log(`[${timeStr}] ${message}`);
        }

        /**
         * æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
         */
        function showStatus(message, type) {
            status.textContent = message;
            status.className = `status show ${type}`;
        }

        /**
         * éšè—çŠ¶æ€æ¶ˆæ¯
         */
        function hideStatus() {
            status.className = 'status';
        }

        /**
         * åŠ è½½è¯´è¯äººåˆ—è¡¨
         */
        async function loadSpeakers() {
            try {
                const response = await fetch('/api/speakers');
                const data = await response.json();
                
                if (data.speakers && data.speakers.length > 0) {
                    availableSpeakers = data.speakers;
                    speakerSelect.innerHTML = '';
                    
                    // æŸ¥æ‰¾é»˜è®¤è¯´è¯äºº"jokè€å¸ˆ"
                    const defaultSpeaker = 'jokè€å¸ˆ';
                    let hasDefault = false;
                    
                    data.speakers.forEach(speaker => {
                        const option = document.createElement('option');
                        option.value = speaker;
                        option.textContent = speaker;
                        
                        // è®¾ç½®é»˜è®¤é€‰ä¸­
                        if (speaker === defaultSpeaker) {
                            option.selected = true;
                            hasDefault = true;
                        }
                        
                        speakerSelect.appendChild(option);
                    });
                    
                    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°jokè€å¸ˆï¼Œå°†ç¬¬ä¸€ä¸ªè¯´è¯äººç§»åˆ°æœ€å‰é¢å¹¶é€‰ä¸­
                    if (!hasDefault && data.speakers.length > 0) {
                        speakerSelect.selectedIndex = 0;
                    }
                    
                    log(`æˆåŠŸåŠ è½½ ${data.speakers.length} ä¸ªè¯´è¯äººï¼Œé»˜è®¤: ${speakerSelect.value}`);
                } else {
                    speakerSelect.innerHTML = '<option value="">ä½¿ç”¨é»˜è®¤è¯´è¯äºº</option>';
                    log('æœªåŠ è½½åˆ°è¯´è¯äººåˆ—è¡¨ï¼Œå°†ä½¿ç”¨æœåŠ¡ç«¯é»˜è®¤è¯´è¯äºº');
                }
            } catch (error) {
                console.error('åŠ è½½è¯´è¯äººåˆ—è¡¨å¤±è´¥:', error);
                speakerSelect.innerHTML = '<option value="">ä½¿ç”¨é»˜è®¤è¯´è¯äºº</option>';
                log('åŠ è½½è¯´è¯äººåˆ—è¡¨å¤±è´¥ï¼Œå°†ä½¿ç”¨æœåŠ¡ç«¯é»˜è®¤è¯´è¯äºº');
            }
        }

        /**
         * åˆå§‹åŒ– Web Audio API
         */
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                nextPlayTime = 0;
            }
            return audioContext;
        }

        /**
         * åˆå¹¶å­—èŠ‚æ•°ç»„
         */
        function mergeUint8Arrays(arr1, arr2) {
            const merged = new Uint8Array(arr1.length + arr2.length);
            merged.set(arr1, 0);
            merged.set(arr2, arr1.length);
            return merged;
        }

        /**
         * æ’­æ”¾éŸ³é¢‘å—
         */
        async function playAudioChunk(pcmData) {
            // æ£€æŸ¥æ˜¯å¦å¯ç”¨è‡ªåŠ¨æ’­æ”¾
            if (!autoPlaySwitch.checked) {
                return;
            }

            if (!pcmData || pcmData.length === 0) {
                return;
            }

            const ctx = initAudioContext();
            
            // ç¡®ä¿æ•°æ®é•¿åº¦æ˜¯2çš„å€æ•°ï¼ˆInt16Array éœ€è¦ï¼‰
            let validLength = pcmData.length;
            if (validLength % 2 !== 0) {
                validLength -= 1;
            }

            if (validLength === 0) {
                return;
            }

            // åˆ›å»ºå¯¹é½çš„æ•°æ®è§†å›¾
            const alignedData = new Uint8Array(pcmData.buffer, pcmData.byteOffset, validLength);
            
            // å°† Int16 PCM æ•°æ®è½¬æ¢ä¸º Float32
            const int16Array = new Int16Array(alignedData.buffer, alignedData.byteOffset, validLength / 2);
            const float32Array = new Float32Array(int16Array.length);
            
            for (let i = 0; i < int16Array.length; i++) {
                float32Array[i] = int16Array[i] / 32768.0;
            }

            // åˆ›å»ºéŸ³é¢‘ç¼“å†²åŒº
            // CosyVoice2 é»˜è®¤é‡‡æ ·ç‡ä¸º 24000ï¼ŒCosyVoice1 ä¸º 22050
            // è¿™é‡Œè®¾ç½®ä¸º 24000 ä»¥åŒ¹é… CosyVoice2-0.5B
            const sampleRate = 24000;
            const audioBuffer = ctx.createBuffer(1, float32Array.length, sampleRate);
            audioBuffer.getChannelData(0).set(float32Array);

            // åˆ›å»ºéŸ³é¢‘æº
            const source = ctx.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(ctx.destination);

            // è®¡ç®—æ’­æ”¾æ—¶é—´
            const currentTime = ctx.currentTime;
            if (nextPlayTime < currentTime) {
                nextPlayTime = currentTime;
            }

            source.start(nextPlayTime);
            nextPlayTime += audioBuffer.duration;
        }

        /**
         * ç”Ÿæˆè¯­éŸ³
         */
        async function generateSpeech() {
            const text = textInput.value.trim();
            const speaker = speakerSelect.value;

            if (!text) {
                showStatus('è¯·è¾“å…¥æ–‡æœ¬å†…å®¹', 'error');
                return;
            }

            // å…è®¸ speaker ä¸ºç©ºï¼ŒæœåŠ¡ç«¯ä¼šä½¿ç”¨é»˜è®¤è¯´è¯äºº

            // é‡ç½®çŠ¶æ€
            audioChunks = [];
            pendingBytes = new Uint8Array(0);
            isStreamingComplete = false;
            isFirstChunk = true;
            generateBtn.disabled = true;
            downloadBtn.disabled = true;
            audioSection.classList.remove('show');
            showStatus('æ­£åœ¨ç”Ÿæˆè¯­éŸ³...', 'loading');
            status.innerHTML = '<span class="loading-spinner"></span>ç­‰å¾…é¦–åŒ…...';

            // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆä»…å½“å¯ç”¨è‡ªåŠ¨æ’­æ”¾æ—¶ï¼‰
            if (autoPlaySwitch.checked) {
                const ctx = initAudioContext();
                if (ctx.state === 'suspended') {
                    await ctx.resume();
                }
                nextPlayTime = ctx.currentTime;
            }

            try {
                // æ„å»ºè¡¨å•æ•°æ®
                const formData = new FormData();
                formData.append('text', text);
                formData.append('speaker', speaker);

                // è®°å½•è¯·æ±‚å¼€å§‹æ—¶é—´ (ä½¿ç”¨é«˜ç²¾åº¦æ—¶é—´)
                requestStartTime = performance.now();
                // log(`[CosyVoice] è¯·æ±‚å¼€å§‹æ—¶é—´: ${new Date().toISOString()}`);

                // å‘é€è¯·æ±‚
                const response = await fetch('/tts', {
                    method: 'POST',
                    headers: {
                        'Connection': 'keep-alive'
                    },
                    body: formData
                });

                if (!response.ok) {
                    throw new Error('æœåŠ¡å™¨å“åº”é”™è¯¯');
                }

                // è¯»å–æµå¼å“åº”å¹¶ç«‹å³æ’­æ”¾
                const reader = response.body.getReader();
                let chunkCount = 0;
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        isStreamingComplete = true;
                        // æ’­æ”¾å‰©ä½™çš„å­—èŠ‚
                        if (pendingBytes.length > 0) {
                            await playAudioChunk(pendingBytes);
                        }
                        break;
                    }

                    // é¦–åŒ…åˆ°è¾¾æ—¶çš„è®¡æ—¶
                    if (isFirstChunk) {
                        firstChunkTime = performance.now();
                        firstChunkSize = value.length;
                        const ttfb = (firstChunkTime - requestStartTime).toFixed(2);
                        log(`â±ï¸ é¦–åŒ…å»¶è¿Ÿ (TTFB): ${ttfb}ms`);
                        log(`ğŸ“¦ é¦–åŒ…å¤§å°: ${firstChunkSize} å­—èŠ‚`);
                        // log(`ğŸš€ é¦–åŒ…æ—¶é—´æˆ³: ${new Date().toISOString()}`);
                    }

                    // å°†æ¥æ”¶åˆ°çš„æ•°æ®å—æ·»åŠ åˆ°æ•°ç»„ï¼ˆç”¨äºä¸‹è½½ï¼‰
                    audioChunks.push(value);
                    chunkCount++;

                    // åˆå¹¶å¾…å¤„ç†çš„å­—èŠ‚å’Œæ–°æ•°æ®
                    pendingBytes = mergeUint8Arrays(pendingBytes, value);

                    // ç¡®ä¿æœ‰è¶³å¤Ÿçš„å­—èŠ‚è¿›è¡Œæ’­æ”¾ï¼ˆè‡³å°‘2å­—èŠ‚ï¼Œå³ä¸€ä¸ªInt16æ ·æœ¬ï¼‰
                    if (pendingBytes.length >= 2) {
                        // è®¡ç®—å¯ä»¥æ’­æ”¾çš„å­—èŠ‚æ•°ï¼ˆå¿…é¡»æ˜¯2çš„å€æ•°ï¼‰
                        const playableLength = Math.floor(pendingBytes.length / 2) * 2;
                        
                        if (playableLength > 0) {
                            // æå–å¯æ’­æ”¾çš„æ•°æ®
                            const playableData = pendingBytes.slice(0, playableLength);
                            
                            // ç«‹å³æ’­æ”¾éŸ³é¢‘å—
                            await playAudioChunk(playableData);
                            
                            // ä¿ç•™å‰©ä½™çš„å­—èŠ‚
                            pendingBytes = pendingBytes.slice(playableLength);
                        }
                    }

                    // é¦–åŒ…åˆ°è¾¾
                    if (isFirstChunk) {
                        isFirstChunk = false;
                        const playModeText = autoPlaySwitch.checked ? 'æµå¼æ’­æ”¾' : 'æ¥æ”¶æ•°æ®';
                        audioInfo.textContent = autoPlaySwitch.checked ? 'ğŸµ éŸ³é¢‘æ­£åœ¨å®æ—¶æµå¼æ’­æ”¾...' : 'ğŸ“¥ éŸ³é¢‘æ•°æ®æ¥æ”¶ä¸­ï¼ˆåå°æ¨¡å¼ï¼‰...';
                        showStatus(`æ­£åœ¨${playModeText}...`, 'loading');
                        status.innerHTML = `<span class="loading-spinner"></span>æ­£åœ¨${playModeText}... (å·²æ¥æ”¶ ${chunkCount} å—)`;
                        audioSection.classList.add('show');
                    } else {
                        // æ›´æ–°æ¥æ”¶çŠ¶æ€
                        const playModeText = autoPlaySwitch.checked ? 'æµå¼æ’­æ”¾' : 'æ¥æ”¶æ•°æ®';
                        status.innerHTML = `<span class="loading-spinner"></span>æ­£åœ¨${playModeText}... (å·²æ¥æ”¶ ${chunkCount} å—)`;
                    }
                }

                // æµå¼æ’­æ”¾å®Œæˆï¼Œå‡†å¤‡ä¸‹è½½éŸ³é¢‘
                const audioBlob = createWavBlob(audioChunks);
                const audioUrl = URL.createObjectURL(audioBlob);
                audioPlayer.src = audioUrl;

                downloadBtn.disabled = false;
                
                // è®¡ç®—å¹¶è¾“å‡ºå®Œæ•´çš„æ€§èƒ½æ•°æ®
                const totalTime = performance.now() - requestStartTime;
                const ttfb = firstChunkTime - requestStartTime;
                const streamingTime = totalTime - ttfb;
                const totalSize = audioChunks.reduce((acc, chunk) => acc + chunk.length, 0);
                const avgChunkSize = Math.floor(totalSize / chunkCount);
                
                const completionText = autoPlaySwitch.checked ? 'æµå¼æ’­æ”¾å®Œæˆ' : 'éŸ³é¢‘æ¥æ”¶å®Œæˆ';
                log(`ğŸ¯ ${completionText}ï¼`);
                log(`â±ï¸ é¦–åŒ…å»¶è¿Ÿ (TTFB): ${ttfb.toFixed(2)}ms`);
                log(`â±ï¸ æµå¼ä¼ è¾“æ—¶é—´: ${streamingTime.toFixed(2)}ms`);
                log(`â±ï¸ æ€»è€—æ—¶: ${totalTime.toFixed(2)}ms`);
                log(`ğŸ“¦ æ€»éŸ³é¢‘å¤§å°: ${totalSize} å­—èŠ‚`);
                log(`ğŸ“Š æ¥æ”¶å—æ•°: ${chunkCount} å—`);
                log(`ğŸ“Š å¹³å‡å—å¤§å°: ${avgChunkSize} å­—èŠ‚`);
                log(`ğŸ“Š å¹³å‡ååé‡: ${(totalSize / (totalTime / 1000) / 1024).toFixed(2)} KB/s`);
                
                audioInfo.textContent = autoPlaySwitch.checked ? 
                    'âœ… æµå¼æ’­æ”¾å®Œæˆï¼Œå¯ä»¥é‡æ–°æ’­æ”¾æˆ–ä¸‹è½½' : 
                    'âœ… éŸ³é¢‘æ¥æ”¶å®Œæˆï¼Œç‚¹å‡»æ’­æ”¾å™¨è¯•å¬æˆ–ä¸‹è½½';
                showStatus(`${completionText}ï¼TTFB: ${ttfb.toFixed(0)}ms`, 'success');

                // 3ç§’åéšè—çŠ¶æ€
                setTimeout(hideStatus, 3000);

            } catch (error) {
                console.error('ç”Ÿæˆå¤±è´¥:', error);
                showStatus('ç”Ÿæˆå¤±è´¥: ' + error.message, 'error');
            } finally {
                generateBtn.disabled = false;
            }
        }

        /**
         * åˆ›å»º WAV æ ¼å¼çš„éŸ³é¢‘ Blob
         */
        function createWavBlob(chunks) {
            // åˆå¹¶æ‰€æœ‰éŸ³é¢‘æ•°æ®å—
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const pcmData = new Uint8Array(totalLength);
            let offset = 0;
            
            for (const chunk of chunks) {
                pcmData.set(chunk, offset);
                offset += chunk.length;
            }

            // åˆ›å»º WAV æ–‡ä»¶å¤´
            const sampleRate = 22050; // é‡‡æ ·ç‡
            const numChannels = 1; // å•å£°é“
            const bitsPerSample = 16; // 16ä½
            
            const wavHeader = createWavHeader(pcmData.length, sampleRate, numChannels, bitsPerSample);
            
            // åˆå¹¶å¤´éƒ¨å’Œæ•°æ®
            const wavData = new Uint8Array(wavHeader.length + pcmData.length);
            wavData.set(wavHeader, 0);
            wavData.set(pcmData, wavHeader.length);
            
            return new Blob([wavData], { type: 'audio/wav' });
        }

        /**
         * åˆ›å»º WAV æ–‡ä»¶å¤´
         */
        function createWavHeader(dataLength, sampleRate, numChannels, bitsPerSample) {
            const header = new ArrayBuffer(44);
            const view = new DataView(header);
            
            const byteRate = sampleRate * numChannels * bitsPerSample / 8;
            const blockAlign = numChannels * bitsPerSample / 8;
            
            // "RIFF" chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            
            // "fmt " sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size
            view.setUint16(20, 1, true); // AudioFormat (PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            
            // "data" sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            
            return new Uint8Array(header);
        }

        /**
         * åˆ›å»º WAV æ ¼å¼çš„éŸ³é¢‘ Blob
         */
        function createWavBlob(chunks) {
            // åˆå¹¶æ‰€æœ‰éŸ³é¢‘æ•°æ®å—
            const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
            const pcmData = new Uint8Array(totalLength);
            let offset = 0;
            
            for (const chunk of chunks) {
                pcmData.set(chunk, offset);
                offset += chunk.length;
            }

            // åˆ›å»º WAV æ–‡ä»¶å¤´
            const sampleRate = 24000; // é‡‡æ ·ç‡ 24000
            const numChannels = 1; // å•å£°é“
            const bitsPerSample = 16; // 16ä½
            
            const wavHeader = createWavHeader(pcmData.length, sampleRate, numChannels, bitsPerSample);
            
            // åˆå¹¶å¤´éƒ¨å’Œæ•°æ®
            const wavData = new Uint8Array(wavHeader.length + pcmData.length);
            wavData.set(wavHeader, 0);
            wavData.set(pcmData, wavHeader.length);
            
            return new Blob([wavData], { type: 'audio/wav' });
        }        /**
         * å†™å…¥å­—ç¬¦ä¸²åˆ° DataView
         */
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        /**
         * ä¸‹è½½éŸ³é¢‘
         */
        function downloadAudio() {
            if (audioChunks.length === 0) {
                showStatus('æ²¡æœ‰å¯ä¸‹è½½çš„éŸ³é¢‘', 'error');
                return;
            }

            const audioBlob = createWavBlob(audioChunks);
            const url = URL.createObjectURL(audioBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cosyvoice_${Date.now()}.wav`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showStatus('ä¸‹è½½æˆåŠŸï¼', 'success');
            setTimeout(hideStatus, 2000);
        }

        /**
         * æ¸…é™¤éŸ³é¢‘
         */
        function clearAudio() {
            audioChunks = [];
            audioPlayer.src = '';
            audioSection.classList.remove('show');
            downloadBtn.disabled = true;
            hideStatus();
            
            // åœæ­¢éŸ³é¢‘ä¸Šä¸‹æ–‡
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            nextPlayTime = 0;
            
            log('ğŸ—‘ï¸ å·²æ¸…é™¤éŸ³é¢‘æ•°æ®');
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            loadSpeakers();
        });

        // äº‹ä»¶ç›‘å¬
        generateBtn.addEventListener('click', generateSpeech);
        downloadBtn.addEventListener('click', downloadAudio);
        clearBtn.addEventListener('click', clearAudio);
        
        // å›è½¦é”®è§¦å‘ç”Ÿæˆ
        textInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                generateSpeech();
            }
        });
    </script>
</body>
</html>
